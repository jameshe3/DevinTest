# Rockset 分析（Analytics）查询优化方案

## 查询优化概述

Rockset 提供了全功能的 SQL 支持，包括聚合、过滤、窗口函数和连接操作，使其能够高效地执行分析查询。Rockset 的查询优化器使用一组启发式规则来估计最佳执行计划，但在某些情况下，这些启发式规则可能不是最优的。为了解决这个问题，Rockset 提供了优化器提示（optimizer hints）机制，允许用户指导查询执行过程。

## 索引优化

Rockset 为所有摄入的数据自动创建三种类型的索引，每种索引针对不同类型的查询进行了优化：

### 1. 行索引（Row Index）

- **存储特点**：同一文档的所有字段值连续存储
- **适用场景**：高效检索特定文档的所有字段（如 `SELECT *`）
- **限制**：对于其他类型的查询较慢，不能强制使用此索引

### 2. 列索引（Columnar Index）

- **存储特点**：同一字段在所有文档中的值连续存储
- **适用场景**：高效检索特定字段的所有值，特别适合聚合操作（如 `SELECT AVG(a) FROM foo`）
- **强制使用**：可以通过添加 `HINT(access_path=column_scan)` 在集合名称后立即强制使用列索引

### 3. 搜索索引（Search Index）

- **存储特点**：按字段和值排序，相同字段的相等值连续存储
- **适用场景**：高效检索字段具有特定值的文档（如 `SELECT COUNT(*) FROM foo WHERE a = 5`）
- **强制使用**：可以通过添加 `HINT(access_path=index_filter)` 在集合名称后立即强制使用搜索索引
- **范围查询优化**：对于需要按特定字段排序的范围查询，可以使用 `HINT(access_path=index_scan, index_scan_sort_field=XYZ)`

搜索索引在查询的 `WHERE` 子句中有可索引术语时总是被使用。如果 `WHERE` 子句的选择性不高，使用列索引可能会获得更好的性能。

特殊字段 `_event_time` 在搜索索引中有特殊优化，查询此字段比查询常规字段更高效。

## SQL 连接优化

Rockset 的 SQL 引擎支持四种类型的连接，每种连接适用于不同的场景：

### 1. 哈希连接（Hash Join）

- **默认连接策略**，通常是最佳选择
- **工作原理**：构建一个哈希集合，然后流式处理另一个集合的值
- **内存要求**：整个被连接的集合必须适合内存
- **分布式执行**：对于等值连接，工作可以分布在多个服务器上
- **强制使用**：`HINT(join_strategy=hash)`（默认，通常不需要显式指定）

### 2. 嵌套循环连接（Nested Loop Join）

- **特点**：较慢，内存消耗较低
- **适用场景**：处理任意大小的集合，不受内存限制
- **缺点**：由于 N^2 的行为，通常不是理想选择
- **强制使用**：`HINT(join_strategy=nested_loops)`

### 3. 广播连接（Broadcast Join）

- **工作原理**：将一个集合的值广播到服务另一个集合的所有叶节点
- **适用场景**：当一个集合明显大于另一个集合，且连接具有选择性时
- **优势**：避免了大量网络开销
- **强制使用**：`HINT(join_broadcast=true)`

### 4. 查找连接（Lookup Join）

- **工作原理**：直接在搜索索引中查找值，而不是构建哈希集
- **适用场景**：仅适用于单字段的等值连接，且一个集合中的行数很少（<100）
- **强制使用**：`HINT(join_strategy=lookup)`

## 数据聚类（Data Clustering）

在创建集合时，可以为列式索引指定聚类方案，以优化特定的查询模式：

- **配置方法**：在集合的摄取转换中指定 `CLUSTER BY` 子句
- **工作原理**：具有相同聚类字段值的文档存储在一起
- **优势**：使具有聚类字段谓词的查询更快，因为执行引擎可以智能地避免扫描不匹配的聚类
- **最佳实践**：匹配聚类键前缀的谓词将带来更大的查询执行改进

## 通用 SQL 优化指南

### 1. 使用 EXPLAIN 理解执行策略

Rockset 支持 `EXPLAIN` 命令，以人类可读的文本形式输出查询的执行策略。例如：

```sql
EXPLAIN SELECT COUNT(*) FROM A INNER JOIN B ON A.x = B.x WHERE B.x = 5;
```

### 2. 使用查询分析器（Query Profiler）

在 Rockset 查询编辑器中运行查询后，Rockset 会生成查询执行配置文件的可视化，显示每个操作符使用了多少 CPU 时间和内存。

### 3. 复制谓词（Duplicating Predicates）

尽可能手动下推和复制谓词，将额外或更具选择性的谓词应用于集合，以减少数据流量并提供更快的执行速度。例如：

```sql
SELECT COUNT(*) FROM A INNER JOIN B ON A.x = B.x WHERE B.x = 5 AND A.x = 5
```

### 4. 选择连接策略

确定哪种连接策略最合适。默认的哈希连接通常是一个不错的选择，但如果集合太大而无法存储在内存中，则考虑嵌套循环连接。如果一个集合明显小于另一个集合，考虑广播或查找连接。

### 5. 哈希连接排序

使用哈希连接时，确定是否有更好的连接顺序。一个好的经验法则是将较小的集合放在连接的右侧。如果有一系列连接，通常最好先放置最大的集合，以便在（希望是选择性的）连接期间进行过滤。

### 6. 覆盖访问路径

确定所使用的访问路径是否理想。唯一需要覆盖的情况是在巨大的表上有非选择性谓词时。例如：

```sql
SELECT COUNT(*) FROM A HINT(access_path=column_scan, data_scan_batch_size=30000) WHERE A.x > 0
```

### 7. NULL 操作符优化

使用 `WHERE foo IS NULL` 时，考虑使用 `WHERE foo IS NULL AND foo IS NOT UNDEFINED` 以获得更好的性能。
